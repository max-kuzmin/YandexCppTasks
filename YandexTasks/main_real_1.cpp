/*
В свободное от занятий по программированию время Вася любит играть в самостоятельно придуманную им игру «Жизнь».
Игра происходит на поле, состоящем из n×mn×m одинаковых клеток. Для удобства Вася нумерует все строки поля целыми числами от 11 до nn в порядке сверху-вниз, а также нумерует все столбцы поля целыми числами от 11 до mm в порядке слева-направо.
Вася считает соседними те клетки поля, которые имеют общее ребро.
Процесс игры состоит из kk итераций. На каждой итерации игры каждая клетка поля находится в одном из трех состояний:
Неактивна. На поле Вася помечает такую клетку цифрой 11.
Стабильна. На поле Вася помечает такую клетку цифрой 22.
Нестабильна. На поле Вася помечает такую клетку цифрой 33.
Активными Вася называет те клетки поля, которые находятся в стабильном или нестабильном состояниях.
Вася начинает игру с поля, каждая клетка которого находится в некотором заранее выбранном им состоянии.
При переходе к следующей итерации игры Вася формирует новое поле, состояние каждой клетки в котором назначается по следующим правилам:
Если у клетки на предыдущей итерации была более, чем одна соседняя клетка в стабильном состоянии, то на следующей итерации клетка будет находиться в стабильном состоянии.
Если не выполняется первое правило и у клетки на предыдущей итерации был хотя бы один сосед в активном состоянии, то на следующей итерации клетка будет находиться в нестабильном состоянии.
Если не выполняются предыдущие правила, то на следующей итерации клетка будет находиться в неактивном состоянии.
Вася хочет заранее спланировать для каждой клетки, сколько изменений состояния ему придется сделать за весь ход игры. Так как Вася еще не успел разобраться во всех тонкостях программирования, он просит Вас помочь ему в этой задаче.
Формат ввода

В первой строке входных данных записано три целых числа — nn, mm, kk ( 1≤n,m,k≤1001≤n,m,k≤100).
В последующих nn строках записано состояние каждой клетки исходно выбранного Васей поля. В ii-й ( 1≤i≤n1≤i≤n) из этих строк записано mm чисел — ai1,…,aimai1,…,aim, где aij∈{1,2,3}aij∈{1,2,3} — состояние клетки в строке с номером ii и столбце с номером jj исходно выбранного Васей поля.
Все числа в каждой строке разделены ровно одним пробелом.
Формат вывода

В ii-й ( 1≤i≤n1≤i≤n) строке выходных данных Вам необходимо вывести mm целых чисел — bi1,…,bimbi1,…,bim, где bijbij — количество изменений состояния клетки в строке с номером ii и столбце с номером jj.
*/


#include <iostream>
#include <fstream>
#include <cstring>

using namespace std;

int main01(int argc, char* argv[])
{
    ifstream ifile;
    ifile.open("input.txt");

    int n, m, k;
    ifile >> n >> m >> k;
    char** cur = new char* [n];
    char** next = new char* [n];
    int* changes = new int[n * m];

    for (int i = 0; i < n; i++)
    {
        cur[i] = new char[m];
        next[i] = new char[m];

        for (int j = 0; j < m; j++)
        {
            ifile >> cur[i][j];
            changes[i * m + j] = 0;
        }
    }


    ifile.close();

    for (int x = 0; x < k; x++)
    {
        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {

                int stable = 0, nostable = 0, noactive = 0;

                if (i > 0)
                {
                    if (cur[i - 1][j] == '1')
                        noactive++;
                    else if (cur[i - 1][j] == '2')
                        stable++;
                    else
                        nostable++;
                }
                if (i < (n - 1))
                {
                    if (cur[i + 1][j] == '1')
                        noactive++;
                    else if (cur[i + 1][j] == '2')
                        stable++;
                    else
                        nostable++;
                }
                if (j > 0)
                {
                    if (cur[i][j - 1] == '1')
                        noactive++;
                    else if (cur[i][j - 1] == '2')
                        stable++;
                    else
                        nostable++;
                }
                if (j < (m - 1))
                {
                    if (cur[i][j + 1] == '1')
                        noactive++;
                    else if (cur[i][j + 1] == '2')
                        stable++;
                    else
                        nostable++;
                }

                if (stable > 1)
                    next[i][j] = '2';
                else if ((stable + nostable) >= 1)
                    next[i][j] = '3';
                else
                    next[i][j] = '1';

                if (cur[i][j] != next[i][j])
                    changes[i * m + j]++;
            }
        }

        for (int i = 0; i < n; i++)
        {
            memcpy(cur[i], next[i], m * sizeof(char));
        }

    }

    ofstream ofile;
    ofile.open("output.txt", ios_base::trunc);

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            ofile << changes[i * m + j];
            if (j < (m - 1))
                ofile << " ";
            else
                ofile << endl;
        }
    }


    for (int i = 0; i < n; i++)
    {
        free(cur[i]);
        free(next[i]);

    }

    free(cur);
    free(next);
    free(changes);

    return 0;
}
